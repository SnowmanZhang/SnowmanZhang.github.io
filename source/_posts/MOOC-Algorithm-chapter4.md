---
title: MOOC-Algorithm-chapter4
date: 2018-01-16 19:53:31
tags:
- MOOC
- 算法
categories:
- 编程
---

这一周讲的代码不多，主要都是一些基础知识，比如时间复杂度，个人认为这个还是比较有用的，至少比单纯地做做题目要有用得多。另外就是本章讲了二分算法。这一问题的应用确实比较广，也确实值得单列一章。

- 一个程序或算法的时间效率，也称“时间复杂度”，有时简称“复杂度”
- 复杂度常用大的字母O和小写字母n来表示，比如O(n),O(n2)等。n代表问题 的规模
- 时间复杂度是用算法运行过程中，某种时间固定的操作需要被执行的次数和n 的关系来度量的。在无序数列中查找某个数，复杂度是O(n)
- 计算复杂度的时候，只统计执行次数最多的(n足够大时)那种固定操作的次数 。比如某个算法需要执行加法n2次，除法n次，那么就记其复杂度是O(n2)的。



如果复杂度是多个n的函数之和，则只关心随n的增长增长得最快的那个函 数
O(n3+n2) => O(n3)
O(2n+n3) => O(2n)
O(n! + 3n) => O(n!)
常数复杂度：O(1) 时间(操作次数)和问题的规模无关 
对数复杂度：O(log(n)) 
线性复杂度：O(n) 
多项式复杂度：O(nk ) 
指数复杂度：O(an ) 
阶乘复杂度：O(n! )

**举例**

在无序数列中查找某个数(顺序查找) O(n) 
平面上有n个点，要求出任意两点之间的距离 O(n2) 
插入排序、选择排序、冒泡排序 O(n2) 
快速排序 O( n*log(n)) 
二分查找 O(log(n))


## 1.二分法求根

**题目描述** 求下面方程的一个根：f(x) = x3-5x2+10x-80 = 0 若求出的根是a，则要求 |f(a)| <= 10^-6

这个题目是典型的二分法解决，当然我们存在更优解法，如牛顿迭代法及更多最优化算法。这个里面需要注意的一点是，当根的解为浮点型时，我们不能要求解是等于某个值的，只能说该近似解的误差在某一个量级以内，这是因为计算机的二进制编码无法精准表示十进制浮点数，之所以我们可以“照常”计算浮点数，只是后台的近似处理结果，事实上大部分十进制浮点数都在计算机内存中以一个近似值存储。所以我们不能使用 `==` 来判断是否得到了正解。


```c
double EPS = 1e-6;
double f(double x){return x*x*x - 5*x*x + 10*x -80;}

int BinaryMethod()
{
    double root ,x1=0,x2=100,y;
    root = x1 + (x2-x1)/2;
    int triedTimes =1;
    y = f(root);
    while(fabs(y) > EPS){
        if(y>0) x2= root;
        else    x1=root;
        root = x1 + (x2-x1)/2;
        y = f(root);
        triedTimes++;
    }
    printf("%.8f\n",root);
    printf("%d",triedTimes);
    return 0;
}

```


## 2. 寻一对数

**问题描述** 输入n ( n<= 100,000)个整数，找出其中的两个数，它们之和等于整数m(假定 肯定有解)。题中所有整数都能用 int 表示

解法一

1. 将数组排序，复杂度是O(n×log(n)) 
2. 对数组中的每个元素a\[i\],在数组中二分查找m-a\[i\]，看能否找到。复杂度log(n)，最 坏要查找n-2次，所以查找这部分的复杂度也是O(n×log(n))

这种解法总的复杂度是O(n×log(n))的。

解法二

1. 将数组排序，复杂度是O(n×log(n)) 
2. 查找的时候，设置两个变量i和j,i初值是0,j初值是n-1.看a\[i\]+a\[j\],如果大于m，就让j 减1，如果小于m,就让i加1，直至a\[i\]+a\[j\]=m。

这种解法总的复杂度是O(n×log(n))的。

**感想** 就这两种解法来说，第一种解法一开始是想到了，第二个解法的从两段往中间检索的法子确实是聪明。能够减少相当一部分复杂度(最主要是可以少写两重循环，让程序更加易读)


