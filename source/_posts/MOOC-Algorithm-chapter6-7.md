---
title: MOOC-Algorithm-chapter6-7
date: 2018-01-22 10:52:22
tags: 
- MOOC
- 算法
categories:
- 编程
---

所谓动态规划，听起来很高大上，初看代码会觉得非常像迭代。其实这种感觉是不准确的，动态规划一定会涉及到迭代，但它增加了自己的特性，即利用题目本身的特点来一边计算，一边存储中间态的答案，以尽量减少计算量，避免程序超时或崩溃，换句话说，这章还会继续迭代的道路，并且会更加灵活。

<!--more-->

## 0. 动态规划一般思路

1. 将原问题分解为若干个子问题，子问题和原问题形式相同只是规模变小，若子问题解决则原问题解决。子问题的解一旦求出就会被保存，故每个子问题只求解一次。
2. 确定状态。
    - 所谓状态，就是和子问题相关的各个变量的取值，也即，如果各个变量的取值确定了，这个子问题具体是什么也就确定了。
    - 整个问题的时间复杂度是状态数目乘以计算每个状态所需的时间。
3. 确定一些初始状态的值，即最小子问题的答案，一旦最小子问题的答案设置好，其余答案即可通过它迭代产生并记录。
4. 确定状态转移方程。找出不同的状态之间如何迁移，即如何从一个或多个“值”已知的状态求出另一个状态的值。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”
    - 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。
    - 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采用何种方式演变到当前状态没有关系。


## 1. 数字三角形

**题目描述**    在上面的数字三角形中寻找一条从顶部到底边的路径，使得 路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。

**输入与输出**      

```
5 //三角形行数。下面是三角形 7
3 8
8 1 0 
2 7 4 4 
4 5 2 6 5
```

输出最大和


### 第一版思路

首先我们可以看到，此题使用一般的递归方法即可求解，也就是，我们将题目转换成求解三角形中第`D[i][j]`到底部的最大值和，假设其值为`MaxSum[i][j]` ，则一定有 `MaxSum[i][j] = max(MaxSum[i+1][j],MaxSum[i+1][j+1]) + D[i][j]` 也就是说，这个点的MaxSum等于下边两个相邻点中MaxSum中较大的那个加上自身的`D[i][j]`，然后求解`MaxSum[1][1]`。源码如下


```c
int D[MAX][MAX];
int n;
int MaxSum(int i,int j){
    if(i==n)
        return D[i][j];
    int x = MaxSum(i+1,j);
    int y = MaxSum(i+1,j+1);
    return max(x,y)+D[i][j];
}

int main()
{
    int i,j;
    cin >> n;
    for(i=1;i<=n;i++)
        for(j=1;j<=i;j++)
            cin >> D[i][j];
    cout << MaxSum(1,1) << endl;
    return 0;
}


```

当然这不会是题目的结尾，不然这题直接归到递归题里好了(滑稽)，那么上面这个解法有什么问题呢？问题在于，它极大地浪费了计算资源，越到底层的MaxSum会被计算越来越多次，而这本不必要————一个位置的MaxSum算一次就够了，以后用到再取出来即可。这就是动态规划的思维，一边计算，一边填补中间态，以便后续利用。

### 第二版思路

我们可以再设置一个数组 `maxSum[MAX][MAX]`  记录每一个节点的最大值，一开始它们均为-1，接着在MaxSum函数开头写一条，如果maxSum相应节点的值不为-1(存在已经计算过的值)，则直接返回，否则进行计算，并且在每次得出一个节点的值后，填充数组maxSum对应节点的值，以便后续取用。

```c
int D[MAX][MAX];
int maxSum[MAX][MAX];
int n;
int MaxSum(int i,int j){
    if(maxSum[i][j]!=-1)
        return maxSum[i][j];
    if(i==n)
        maxSum[i][j] = D[i][j];
    else{
    int x = MaxSum(i+1,j);
    int y = MaxSum(i+1,j+1);
    maxSum[i][j] = max(x,y)+D[i][j];
    }
    return maxSum[i][j];
}

int main()
{
    int i,j;
    cin >> n;
    for(i=1;i<=n;i++)
        for(j=1;j<=i;j++)
            cin >> D[i][j];
            maxSum[i][j] = -1;
    cout << MaxSum(1,1) << endl;
    return 0;
}



```


这个题目到这里，就可以AC了，不过题目的特性决定了这还有一个更强大的解法，化递归为递推，也就是说，我们放弃从顶端寻路，而是从低端向上寻路，首先我们根据最后一层数字，推出倒数第二层节点的MaxSum，再以此类推最后到顶点。在存储设置上，我们也不必要再用一个maxSum数组，只需要在原数组上修改即可。

### 第三版思路

```c

#define MAX 101
int D[MAX][MAX];
int maxSum[MAX][MAX];
int n;

int main(){
    int i,j;
    cin >> n;
    for(i=1;i<=n;i++)
        for(j=1;j<=i;j++)
            cin >> D[i][j];
    for(int i=1;i<=n;++i)
        maxSum[n][i] = D[n][i];
    for(int i=n-1;i>=1;--i)
        for(int j = 1;j<=i;++j)
            maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j];
    cout <<maxSum[1][1] << endl;
}
```


